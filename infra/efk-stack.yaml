# efk-all-in-one.yaml
# --- ECK Operator (installs ALL CRDs)
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: eck-operator
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "0"
spec:
  project: default
  source:
    repoURL: https://helm.elastic.co
    chart: eck-operator
    targetRevision: 2.13.x
    helm:
      values: |
        installCRDs: true
  destination:
    server: https://kubernetes.default.svc
    namespace: elastic-system
  syncPolicy:
    automated: { prune: true, selfHeal: true }
    syncOptions:
      - CreateNamespace=true

---
# Namespace for logging stack (created early)
apiVersion: v1
kind: Namespace
metadata:
  name: logging
  annotations:
    argocd.argoproj.io/sync-wave: "1"

---
# Elasticsearch CR (applies AFTER CRDs exist)
apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: elasticsearch
  namespace: logging
  annotations:
    argocd.argoproj.io/sync-wave: "5"
    # Prevent dry-run errors before CRDs are installed
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
spec:
  version: 8.13.0
  nodeSets:
    - name: master
      count: 3
      config:
        node.roles: ["master", "ingest", "data_hot"]
        xpack.security.enabled: true
      podTemplate:
        spec:
          containers:
            - name: elasticsearch
              resources:
                requests: { cpu: "500m", memory: "2Gi" }
                limits:   { cpu: "1",    memory: "4Gi" }
      volumeClaimTemplates:
        - metadata:
            name: elasticsearch-data
          spec:
            accessModes: ["ReadWriteOnce"]
            storageClassName: gp3      # <-- set to your StorageClass
            resources:
              requests:
                storage: 50Gi

---
# Kibana CR
apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: kibana
  namespace: logging
  annotations:
    argocd.argoproj.io/sync-wave: "6"
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
spec:
  version: 8.13.0
  count: 1
  elasticsearchRef:
    name: elasticsearch
  http:
    service:
      spec:
        type: ClusterIP   # change to LoadBalancer/Ingress if needed
  podTemplate:
    spec:
      containers:
        - name: kibana
          resources:
            requests: { cpu: "200m", memory: "512Mi" }
            limits:   { cpu: "500m", memory: "1Gi" }

---
# Fluent Bit via Helm, sending to Elasticsearch service
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: efk-fluent-bit
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "10"
spec:
  project: default
  source:
    repoURL: https://fluent.github.io/helm-charts
    chart: fluent-bit
    targetRevision: 0.x.x
    helm:
      values: |
        daemonSetVolumes:
          - name: varlog
            hostPath: { path: /var/log }
          - name: varlibdockercontainers
            hostPath: { path: /var/lib/docker/containers }
        daemonSetVolumeMounts:
          - name: varlog
            mountPath: /var/log
          - name: varlibdockercontainers
            mountPath: /var/lib/docker/containers
            readOnly: true
        config:
          outputs: |
            [OUTPUT]
                Name  es
                Match *
                Host  elasticsearch-es-http.logging.svc
                Port  9200
                Logstash_Format On
                Retry_Limit  False
                Suppress_Type_Name On
          filters: |
            [FILTER]
                Name   kubernetes
                Match  kube.*
                Kube_Tag_Prefix kube.var.log.containers.
          service: |
            [SERVICE]
                Parsers_File parsers.conf
          inputs: |
            [INPUT]
                Name              tail
                Path              /var/log/containers/*.log
                Parser            docker
                Tag               kube.*
                Refresh_Interval  5
                Mem_Buf_Limit     50MB
                Skip_Long_Lines   On
  destination:
    server: https://kubernetes.default.svc
    namespace: logging
  syncPolicy:
    automated: { prune: true, selfHeal: true }
    syncOptions:
      - CreateNamespace=true
